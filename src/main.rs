use tree_sitter::{Parser, Tree};

// An enum to represent the two states we care about.
#[derive(Debug, PartialEq, Eq)]
enum LocationState {
    InsideBrackets,
    Outside,
}

// Use an `extern` block to link to the C parser generated by Tree-sitter.
// The function name is `tree_sitter_{grammar_name}`.
#[link(name = "tree_sitter_bracket_parser")]
unsafe extern "C" {
    pub fn tree_sitter_bracket_parser() -> tree_sitter::Language;
}

/// Determines if a given byte position in the source code is inside or outside brackets.
///
/// It works by finding the smallest syntax node at the given position and then
/// walking up the tree to see if any of its ancestors is a bracketed expression.
fn get_location_state(byte_position: usize, tree: &Tree) -> LocationState {
    let root_node = tree.root_node();

    // Find the smallest node that contains the given byte position.
    // This is our starting point.
    let Some(mut node) = root_node.descendant_for_byte_range(byte_position, byte_position) else {
        return LocationState::Outside;
    };

    // Loop upwards from the current node to the root.
    loop {
        let kind = node.kind();

        // Check if the node's type matches one of our bracketed expressions.
        // If it does, we are "inside". This includes being on the bracket
        // characters `(`, `)` themselves, as they are part of the expression node.
        match kind {
            "paren_expression" | "square_expression" | "curly_expression" => {
                return LocationState::InsideBrackets;
            }
            _ => (),
        }

        // Move to the parent node. If there is no parent, we've reached the root.
        if let Some(parent) = node.parent() {
            node = parent;
        } else {
            break; // Reached the root of the tree
        }
    }

    // If we looped all the way to the root without finding a bracketed
    // expression ancestor, we must be outside.
    LocationState::Outside
}

fn main() {
    // 1. Initialize the parser
    let mut parser = Parser::new();

    // 2. Load our custom language
    let language = unsafe { tree_sitter_bracket_parser() };
    parser
        .set_language(&language)
        .expect("Error loading bracket parser grammar");

    // 3. Define some source code to parse
    let source_code = "some text (content) and [more {nested}] items.";
    
    // 4. Parse the source code
    let tree = parser.parse(source_code, None).unwrap();

    // 5. Demonstrate the function by checking the state at each character position
    println!("Analyzing source code: \"{}\"\n", source_code);
    println!("{:<10} | {:<5} | {}", "Character", "Index", "State");
    println!("{}", "-".repeat(40));

    for (i, ch) in source_code.char_indices() {
        let state = get_location_state(i, &tree);
        println!("{:<10} | {:<5} | {:?}", format!("'{}'", ch), i, state);
    }

    // A specific check to show it works
    let test_position = 28; // The 's' in "nested"
    let test_state = get_location_state(test_position, &tree);
    println!("\nCheck for index {}: The character is '{}', state is {:?}.",
        test_position,
        source_code.chars().nth(test_position).unwrap(),
        test_state
    );
    assert_eq!(test_state, LocationState::InsideBrackets);

    let test_position_outside = 4; // The ' ' after "some"
    let test_state_outside = get_location_state(test_position_outside, &tree);
     println!("Check for index {}: The character is '{}', state is {:?}.",
        test_position_outside,
        source_code.chars().nth(test_position_outside).unwrap(),
        test_state_outside
    );
    assert_eq!(test_state_outside, LocationState::Outside);
}