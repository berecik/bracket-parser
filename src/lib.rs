//! A library that recognizes pairs of brackets and determines if a position
//! is inside or outside brackets in text.
//!
//! This library uses tree-sitter for parsing and provides a simple API to
//! analyze text and determine the bracket state at the end of the input.

use tree_sitter::{Parser, Tree};

/// An enum to represent the two possible states for a position in text.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum BracketState {
    /// Position is inside at least one pair of brackets (parentheses, square, or curly).
    Inside,
    /// Position is not inside any brackets.
    Outside,
}

// Link to the C parser generated by Tree-sitter.
#[link(name = "tree_sitter_bracket_parser")]
unsafe extern "C" {
    pub fn tree_sitter_bracket_parser() -> tree_sitter::Language;
}

/// A parser that can analyze text to determine if positions are inside or outside brackets.
pub struct BracketParser {
    parser: Parser,
}

impl BracketParser {
    /// Creates a new BracketParser instance.
    ///
    /// # Returns
    ///
    /// A Result containing the new BracketParser or an error if the parser
    /// could not be initialized.
    pub fn new() -> Result<Self, String> {
        let mut parser = Parser::new();

        // Load the bracket parser language
        let language = unsafe { tree_sitter_bracket_parser() };
        parser
            .set_language(&language)
            .map_err(|e| format!("Error loading bracket parser grammar: {}", e))?;

        Ok(Self { parser })
    }

    /// Parses the given code and returns the bracket state at the end of the input.
    ///
    /// # Arguments
    ///
    /// * `code` - The text to analyze
    ///
    /// # Returns
    ///
    /// The bracket state (Inside or Outside) at the end of the input text.
    pub fn get_final_state(&mut self, code: &str) -> BracketState {
        if code.is_empty() {
            return BracketState::Outside;
        }

        // Parse the code
        let tree = match self.parser.parse(code, None) {
            Some(tree) => tree,
            None => return BracketState::Outside,
        };

        // Get the state at the last byte position
        let last_pos = code.len() - 1;
        self.get_state_at_position(last_pos, &tree)
    }

    /// Gets the bracket state at a specific byte position in the parsed code.
    ///
    /// # Arguments
    ///
    /// * `byte_position` - The byte position to check
    /// * `tree` - The parsed syntax tree
    ///
    /// # Returns
    ///
    /// The bracket state (Inside or Outside) at the specified position.
    pub fn get_state_at_position(&self, byte_position: usize, tree: &Tree) -> BracketState {
        let root_node = tree.root_node();

        // Find the smallest node that contains the given byte position
        let Some(mut node) = root_node.descendant_for_byte_range(byte_position, byte_position) else {
            return BracketState::Outside;
        };

        // Loop upwards from the current node to the root
        loop {
            let kind = node.kind();

            // Check if the node's type matches one of our bracketed expressions
            match kind {
                "paren_expression" | "square_expression" | "curly_expression" => {
                    return BracketState::Inside;
                }
                _ => (),
            }

            // Move to the parent node. If there is no parent, we've reached the root
            if let Some(parent) = node.parent() {
                node = parent;
            } else {
                break; // Reached the root of the tree
            }
        }

        // If we looped all the way to the root without finding a bracketed
        // expression ancestor, we must be outside
        BracketState::Outside
    }

    /// Parses the given code and returns the bracket state at each character position.
    ///
    /// # Arguments
    ///
    /// * `code` - The text to analyze
    ///
    /// # Returns
    ///
    /// A vector of BracketState values, one for each character in the input.
    pub fn get_all_states(&mut self, code: &str) -> Vec<BracketState> {
        if code.is_empty() {
            return Vec::new();
        }

        // Parse the code
        let tree = match self.parser.parse(code, None) {
            Some(tree) => tree,
            None => return vec![BracketState::Outside; code.len()],
        };

        // Check the state at each character position
        code.char_indices()
            .map(|(i, _)| self.get_state_at_position(i, &tree))
            .collect()
    }
}

// Re-export BracketState for convenience
pub use BracketState::{Inside, Outside};

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_string() {
        let mut parser = BracketParser::new().unwrap();
        assert_eq!(parser.get_final_state(""), BracketState::Outside);
    }

    #[test]
    fn test_simple_text() {
        let mut parser = BracketParser::new().unwrap();
        assert_eq!(parser.get_final_state("Hello world"), BracketState::Outside);
    }

    #[test]
    fn test_inside_parentheses() {
        let mut parser = BracketParser::new().unwrap();
        assert_eq!(parser.get_final_state("Hello (world"), BracketState::Inside);
    }

    #[test]
    fn test_closed_parentheses() {
        let mut parser = BracketParser::new().unwrap();
        assert_eq!(parser.get_final_state("Hello (world)"), BracketState::Outside);
    }

    #[test]
    fn test_nested_brackets() {
        let mut parser = BracketParser::new().unwrap();
        assert_eq!(parser.get_final_state("A [B {C}]"), BracketState::Outside);
        assert_eq!(parser.get_final_state("A [B {C"), BracketState::Inside);
    }

    #[test]
    fn test_all_states() {
        let mut parser = BracketParser::new().unwrap();
        let states = parser.get_all_states("a(b)c");
        assert_eq!(states.len(), 5);
        assert_eq!(states[0], BracketState::Outside); // 'a'
        assert_eq!(states[1], BracketState::Inside);  // '('
        assert_eq!(states[2], BracketState::Inside);  // 'b'
        assert_eq!(states[3], BracketState::Inside);  // ')'
        assert_eq!(states[4], BracketState::Outside); // 'c'
    }
}
